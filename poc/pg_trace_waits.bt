#!/usr/bin/env bpftrace
/*
 * pg_trace_waits.bt - Comprehensive PostgreSQL wait event tracer
 *
 * Captures ALL wait event types in PostgreSQL format:
 * - IO: DataFileRead, DataFileWrite, BufFileRead, etc.
 * - LWLock: BufferContent, WALInsert, ProcArray, etc.
 * - Lock: relation, transactionid, tuple, etc.
 * - IPC: ExecuteGather, Hash*, Parallel*, etc.
 * - Client: ClientRead, ClientWrite
 * - Timeout: PgSleep, VacuumDelay, etc.
 *
 * Usage:
 *   sudo bpftrace pg_trace_waits.bt                       # trace all backends
 *   sudo bpftrace -p 12345 pg_trace_waits.bt              # trace specific PID
 *   sudo TARGET_PID=12345 bpftrace pg_trace_waits.bt      # alternative PID filter
 *
 * Output format: TIM,EVENT_TYPE,NODE_PTR,WAIT_EVENT_INFO,DETAILS
 * Wait event info is raw 32-bit value, decode in Python:
 *   class = (wait_event_info >> 24) & 0xFF
 *   event_id = wait_event_info & 0xFFFFFF
 */

BEGIN {
    printf("# PG_TRACE_WAITS - Comprehensive Wait Event Tracer\n");
    printf("# TIMESTAMP: %s\n", strftime("%Y%m%d%H%M%S", nsecs));
    printf("# FORMAT: TIM,EVENT,NODE_PTR,WAIT_INFO,DETAILS\n");
    printf("# WAIT_INFO: 0xCCEEEEEE where CC=class, EEEEEE=event_id\n");
    printf("# Classes: 01=LWLock 03=Lock 04=BufferPin 05=Activity 06=Client 08=IPC 09=Timeout 0A=IO\n");
    printf("# Threshold: 100us\n");
    printf("#\n");

    /*
     * Note: Using literal values in comparisons to avoid bpftrace type warnings.
     * Threshold: 100000 ns = 100 us (minimum wait to report)
     * CLASS_ACTIVITY = 5 (filter out idle backend noise)
     * CLASS_LWLOCK = 1, CLASS_LOCK = 3
     */
}

/*
 * Query execution tracking - only trace waits during query execution
 */
uprobe:/usr/pgsql-13/bin/postgres:standard_ExecutorRun {
    @query_start[tid] = nsecs;
    @in_query[tid] = 1;

    printf("%lu,QUERY_START,0,0,pid=%d\n", nsecs/1000, pid);
}

uretprobe:/usr/pgsql-13/bin/postgres:standard_ExecutorRun /@query_start[tid]/ {
    $ela = (nsecs - @query_start[tid]) / 1000;
    printf("%lu,QUERY_END,0,0,pid=%d ela=%lu\n", nsecs/1000, pid, $ela);

    delete(@query_start[tid]);
    delete(@in_query[tid]);
}

/*
 * Node execution tracking - correlate waits to plan nodes
 */
uprobe:/usr/pgsql-13/bin/postgres:InstrStartNode {
    $instr = arg0;

    @depth[tid]++;
    $d = @depth[tid];
    @node_stack[tid, $d] = $instr;
    @node_start[tid, $d] = nsecs;
}

uprobe:/usr/pgsql-13/bin/postgres:InstrStopNode {
    $instr = arg0;
    $d = @depth[tid];

    /* Pop from stack */
    @node_stack[tid, $d] = 0;
    @node_start[tid, $d] = 0;
    if ($d > 0) {
        @depth[tid] = $d - 1;
    }
}

/*
 * =============================================================================
 * WAIT EVENT TRACING - All Types
 * =============================================================================
 */

/*
 * WaitEventSetWait - Catches: Client, IPC, Timeout, Activity waits
 * Signature: int WaitEventSetWait(WaitEventSet *set, long timeout,
 *                                  WaitEvent *occurred_events, int nevents,
 *                                  uint32 wait_event_info)
 */
uprobe:/usr/pgsql-13/bin/postgres:WaitEventSetWait /@in_query[tid]/ {
    @wait_start[tid] = nsecs;
    @wait_event[tid] = arg4;  /* wait_event_info is arg4 */

    /* Get current node from stack */
    $d = @depth[tid];
    @wait_node[tid] = @node_stack[tid, $d];
}

uretprobe:/usr/pgsql-13/bin/postgres:WaitEventSetWait /@wait_start[tid] && @in_query[tid]/ {
    $ela = (nsecs - @wait_start[tid]);
    $wait_info = @wait_event[tid];
    $node = @wait_node[tid];
    $class = ($wait_info >> 24) & 0xFF;

    /* Filter: >100us threshold, skip Activity class (5) */
    if ($ela > 100000 && $class != 5) {
        printf("%lu,WAIT,0x%lx,0x%08x,ela=%lu\n",
               nsecs/1000, $node, $wait_info, $ela/1000);
    }

    delete(@wait_start[tid]);
    delete(@wait_event[tid]);
    delete(@wait_node[tid]);
}

/*
 * LWLockAcquire - Lightweight lock waits
 * Signature: bool LWLockAcquire(LWLock *lock, LWLockMode mode)
 *
 * We trace entry/exit and only report if it took > threshold (indicates contention)
 */
uprobe:/usr/pgsql-13/bin/postgres:LWLockAcquire /@in_query[tid]/ {
    @lwlock_start[tid] = nsecs;
    @lwlock_id[tid] = arg0;  /* LWLock pointer - can get tranche ID from it */
    @lwlock_mode[tid] = arg1;

    $d = @depth[tid];
    @lwlock_node[tid] = @node_stack[tid, $d];
}

uretprobe:/usr/pgsql-13/bin/postgres:LWLockAcquire /@lwlock_start[tid] && @in_query[tid]/ {
    $ela = nsecs - @lwlock_start[tid];

    /* Only report if waited longer than 100us (indicates contention) */
    if ($ela > 100000) {
        $node = @lwlock_node[tid];
        $lock_ptr = @lwlock_id[tid];
        $mode = @lwlock_mode[tid];

        /* Read tranche ID from LWLock structure (offset 0 typically) */
        $tranche = *(uint16*)$lock_ptr;

        /* Build wait_event_info: class=0x01 (LWLock), event=tranche_id */
        $wait_info = (1 << 24) | $tranche;

        printf("%lu,LWLOCK,0x%lx,0x%08x,mode=%d ela=%lu\n",
               nsecs/1000, $node, $wait_info, $mode, $ela/1000);
    }

    delete(@lwlock_start[tid]);
    delete(@lwlock_id[tid]);
    delete(@lwlock_mode[tid]);
    delete(@lwlock_node[tid]);
}

/*
 * ProcSleep - Heavyweight lock waits (table locks, row locks, transaction locks)
 * Signature: int ProcSleep(LOCALLOCK *locallock, LockMethod lockMethodTable)
 *
 * This is called when a process actually has to WAIT for a heavyweight lock
 */
uprobe:/usr/pgsql-13/bin/postgres:ProcSleep /@in_query[tid]/ {
    @procsleep_start[tid] = nsecs;
    @procsleep_lock[tid] = arg0;  /* LOCALLOCK pointer */

    $d = @depth[tid];
    @procsleep_node[tid] = @node_stack[tid, $d];

    /* This is a real lock wait - always report entry */
    printf("%lu,LOCK_WAIT_START,0x%lx,0,lock=%lx\n",
           nsecs/1000, @procsleep_node[tid], arg0);
}

uretprobe:/usr/pgsql-13/bin/postgres:ProcSleep /@procsleep_start[tid]/ {
    $ela = (nsecs - @procsleep_start[tid]) / 1000;
    $node = @procsleep_node[tid];

    /* Build wait_event_info: class=0x03 (Lock) */
    $wait_info = (3 << 24);

    printf("%lu,LOCK,0x%lx,0x%08x,ela=%lu\n",
           nsecs/1000, $node, $wait_info, $ela);

    delete(@procsleep_start[tid]);
    delete(@procsleep_lock[tid]);
    delete(@procsleep_node[tid]);
}

/*
 * =============================================================================
 * IO TRACING - Read and Write
 * =============================================================================
 */

/*
 * mdread - Physical read from data file
 * Signature: void mdread(SMgrRelation reln, ForkNumber forknum,
 *                        BlockNumber blocknum, char *buffer)
 *
 * SMgrRelation points to RelFileNode: { spcNode, dbNode, relNode }
 * File path: $PGDATA/base/<dbNode>/<relNode> (for default tablespace)
 */
uprobe:/usr/pgsql-13/bin/postgres:mdread /@in_query[tid]/ {
    @io_start[tid] = nsecs;
    @io_spc[tid] = *(uint32*)(arg0 + 0);   /* spcNode - tablespace */
    @io_db[tid] = *(uint32*)(arg0 + 4);    /* dbNode - database */
    @io_rel[tid] = *(uint32*)(arg0 + 8);   /* relNode - relation */
    @io_fork[tid] = arg1;
    @io_blk[tid] = arg2;

    $d = @depth[tid];
    @io_node[tid] = @node_stack[tid, $d];
}

uretprobe:/usr/pgsql-13/bin/postgres:mdread /@io_start[tid]/ {
    $ela = (nsecs - @io_start[tid]) / 1000;
    $node = @io_node[tid];
    $spc = @io_spc[tid];
    $db = @io_db[tid];
    $rel = @io_rel[tid];
    $blk = @io_blk[tid];
    $fork = @io_fork[tid];

    /* IO:DataFileRead = 0x0A00000D */
    $wait_info = 0x0A00000D;

    printf("%lu,IO_READ,0x%lx,0x%08x,spc=%u db=%u rel=%u fork=%u blk=%u ela=%lu\n",
           nsecs/1000, $node, $wait_info, $spc, $db, $rel, $fork, $blk, $ela);

    delete(@io_start[tid]);
    delete(@io_spc[tid]);
    delete(@io_db[tid]);
    delete(@io_rel[tid]);
    delete(@io_fork[tid]);
    delete(@io_blk[tid]);
    delete(@io_node[tid]);
}

/*
 * mdwrite - Physical write to data file
 * Signature: void mdwrite(SMgrRelation reln, ForkNumber forknum,
 *                         BlockNumber blocknum, char *buffer, bool skipFsync)
 */
uprobe:/usr/pgsql-13/bin/postgres:mdwrite /@in_query[tid]/ {
    @iowr_start[tid] = nsecs;
    @iowr_spc[tid] = *(uint32*)(arg0 + 0);
    @iowr_db[tid] = *(uint32*)(arg0 + 4);
    @iowr_rel[tid] = *(uint32*)(arg0 + 8);
    @iowr_fork[tid] = arg1;
    @iowr_blk[tid] = arg2;

    $d = @depth[tid];
    @iowr_node[tid] = @node_stack[tid, $d];
}

uretprobe:/usr/pgsql-13/bin/postgres:mdwrite /@iowr_start[tid]/ {
    $ela = (nsecs - @iowr_start[tid]) / 1000;
    $node = @iowr_node[tid];
    $spc = @iowr_spc[tid];
    $db = @iowr_db[tid];
    $rel = @iowr_rel[tid];
    $blk = @iowr_blk[tid];
    $fork = @iowr_fork[tid];

    /* IO:DataFileWrite = 0x0A000010 */
    $wait_info = 0x0A000010;

    printf("%lu,IO_WRITE,0x%lx,0x%08x,spc=%u db=%u rel=%u fork=%u blk=%u ela=%lu\n",
           nsecs/1000, $node, $wait_info, $spc, $db, $rel, $fork, $blk, $ela);

    delete(@iowr_start[tid]);
    delete(@iowr_spc[tid]);
    delete(@iowr_db[tid]);
    delete(@iowr_rel[tid]);
    delete(@iowr_fork[tid]);
    delete(@iowr_blk[tid]);
    delete(@iowr_node[tid]);
}

/*
 * =============================================================================
 * CPU TIME TRACKING via scheduler
 * =============================================================================
 */

/*
 * Track when process goes off CPU (starts waiting)
 * Use prev_pid/next_pid from sched_switch (these are thread IDs for threads)
 */
tracepoint:sched:sched_switch /@in_query[args->prev_pid]/ {
    /* Process going OFF cpu */
    $prev = args->prev_pid;

    /* Record when we went off CPU */
    @off_cpu_start[$prev] = nsecs;

    /* Accumulate on-CPU time */
    if (@on_cpu_start[$prev] > 0) {
        @cpu_time[$prev] += nsecs - @on_cpu_start[$prev];
    }
}

tracepoint:sched:sched_switch /@in_query[args->next_pid]/ {
    /* Process coming ON cpu */
    $next = args->next_pid;

    /* Record when we came on CPU */
    @on_cpu_start[$next] = nsecs;

    /* Accumulate off-CPU time (wait time) */
    if (@off_cpu_start[$next] > 0) {
        $off_time = nsecs - @off_cpu_start[$next];
        @wait_time[$next] += $off_time;

        /* Emit OFF_CPU event if significant gap (>100us) */
        if ($off_time > 100000) {
            $d = @depth[$next];
            $node = @node_stack[$next, $d];
            printf("%lu,OFF_CPU,0x%lx,0,ela=%lu\n",
                   nsecs/1000, $node, $off_time/1000);
        }
    }
}

/*
 * =============================================================================
 * CLEANUP
 * =============================================================================
 */

END {
    printf("\n# === TRACER ENDED ===\n");

    /* Clean up maps */
    clear(@depth);
    clear(@node_stack);
    clear(@node_start);
    clear(@query_start);
    clear(@in_query);
    clear(@wait_start);
    clear(@wait_event);
    clear(@wait_node);
    clear(@lwlock_start);
    clear(@lwlock_id);
    clear(@lwlock_mode);
    clear(@lwlock_node);
    clear(@procsleep_start);
    clear(@procsleep_lock);
    clear(@procsleep_node);
    clear(@io_start);
    clear(@io_spc);
    clear(@io_db);
    clear(@io_rel);
    clear(@io_fork);
    clear(@io_blk);
    clear(@io_node);
    clear(@iowr_start);
    clear(@iowr_spc);
    clear(@iowr_db);
    clear(@iowr_rel);
    clear(@iowr_fork);
    clear(@iowr_blk);
    clear(@iowr_node);
    clear(@off_cpu_start);
    clear(@on_cpu_start);
    clear(@cpu_time);
    clear(@wait_time);
}
