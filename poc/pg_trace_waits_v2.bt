#!/usr/bin/env bpftrace
/*
 * pg_trace_complete.bt - Complete PostgreSQL wait event tracer
 *
 * Captures REAL PostgreSQL wait events:
 * - IO: Via mdread/mdwrite (we know the wait event type)
 * - LWLock: Via LWLockAcquire (tranche ID gives event)
 * - Lock: Via ProcSleep (read from MyProc->wait_event_info)
 * - Client/IPC/Timeout: Via WaitEventSetWait arg4
 */

BEGIN {
    printf("# COMPLETE PostgreSQL Wait Event Tracer\n");
    printf("# FORMAT: TIM,EVENT,NODE_PTR,WAIT_INFO,DETAILS\n");
    printf("#\n");
}

/* Query tracking */
uprobe:/usr/pgsql-13/bin/postgres:standard_ExecutorRun {
    @in_query[tid] = 1;
    printf("%lu,QUERY_START,0,0,pid=%d\n", nsecs/1000, pid);
}

uretprobe:/usr/pgsql-13/bin/postgres:standard_ExecutorRun /@in_query[tid]/ {
    printf("%lu,QUERY_END,0,0,pid=%d\n", nsecs/1000, pid);
    delete(@in_query[tid]);
}

/* Node tracking */
uprobe:/usr/pgsql-13/bin/postgres:InstrStartNode {
    @depth[tid]++;
    $d = @depth[tid];
    @node_stack[tid, $d] = arg0;
}

uprobe:/usr/pgsql-13/bin/postgres:InstrStopNode {
    $d = @depth[tid];
    @node_stack[tid, $d] = 0;
    if ($d > 0) { @depth[tid] = $d - 1; }
}

/* 
 * IO Read - mdread always uses IO:DataFileRead (0x0A00000D)
 */
uprobe:/usr/pgsql-13/bin/postgres:mdread /@in_query[tid]/ {
    @io_start[tid] = nsecs;
    @io_rel[tid] = *(uint32*)(arg0 + 8);
    @io_blk[tid] = arg2;
    $d = @depth[tid];
    @io_node[tid] = @node_stack[tid, $d];
}

uretprobe:/usr/pgsql-13/bin/postgres:mdread /@io_start[tid]/ {
    $ela = (nsecs - @io_start[tid]) / 1000;
    /* IO:DataFileRead = 0x0A00000D */
    printf("%lu,IO,0x%lx,0x0A00000D,rel=%u blk=%u ela=%lu\n",
           nsecs/1000, @io_node[tid], @io_rel[tid], @io_blk[tid], $ela);
    delete(@io_start[tid]); delete(@io_rel[tid]); 
    delete(@io_blk[tid]); delete(@io_node[tid]);
}

/*
 * IO Write - mdwrite always uses IO:DataFileWrite (0x0A000010)
 */
uprobe:/usr/pgsql-13/bin/postgres:mdwrite /@in_query[tid]/ {
    @iowr_start[tid] = nsecs;
    @iowr_rel[tid] = *(uint32*)(arg0 + 8);
    @iowr_blk[tid] = arg2;
    $d = @depth[tid];
    @iowr_node[tid] = @node_stack[tid, $d];
}

uretprobe:/usr/pgsql-13/bin/postgres:mdwrite /@iowr_start[tid]/ {
    $ela = (nsecs - @iowr_start[tid]) / 1000;
    /* IO:DataFileWrite = 0x0A000010 */
    printf("%lu,IO,0x%lx,0x0A000010,rel=%u blk=%u ela=%lu\n",
           nsecs/1000, @iowr_node[tid], @iowr_rel[tid], @iowr_blk[tid], $ela);
    delete(@iowr_start[tid]); delete(@iowr_rel[tid]);
    delete(@iowr_blk[tid]); delete(@iowr_node[tid]);
}

/*
 * LWLock - tranche ID gives the specific lock name
 * Only report if acquisition took >100us (indicates contention/wait)
 */
uprobe:/usr/pgsql-13/bin/postgres:LWLockAcquire /@in_query[tid]/ {
    @lw_start[tid] = nsecs;
    @lw_lock[tid] = arg0;
    @lw_mode[tid] = arg1;
    $d = @depth[tid];
    @lw_node[tid] = @node_stack[tid, $d];
}

uretprobe:/usr/pgsql-13/bin/postgres:LWLockAcquire /@lw_start[tid]/ {
    $ela = nsecs - @lw_start[tid];
    if ($ela > 100000) {
        $lock = @lw_lock[tid];
        $tranche = *(uint16*)$lock;
        /* LWLock class = 0x01 */
        $wait = (1 << 24) | $tranche;
        printf("%lu,LWLOCK,0x%lx,0x%08x,mode=%d ela=%lu\n",
               nsecs/1000, @lw_node[tid], $wait, @lw_mode[tid], $ela/1000);
    }
    delete(@lw_start[tid]); delete(@lw_lock[tid]); 
    delete(@lw_mode[tid]); delete(@lw_node[tid]);
}

/*
 * WaitEventSetWait - Client, IPC, Timeout waits
 * arg4 contains the exact wait_event_info
 */
uprobe:/usr/pgsql-13/bin/postgres:WaitEventSetWait /@in_query[tid]/ {
    @wait_start[tid] = nsecs;
    @wait_arg[tid] = arg4;
    $d = @depth[tid];
    @wait_node[tid] = @node_stack[tid, $d];
}

uretprobe:/usr/pgsql-13/bin/postgres:WaitEventSetWait /@wait_start[tid] && @in_query[tid]/ {
    $ela = (nsecs - @wait_start[tid]) / 1000;
    $wait = @wait_arg[tid];
    $class = ($wait >> 24) & 0xFF;
    /* Report if >100us and not Activity class (5) */
    if ($ela > 100 && $class != 5) {
        printf("%lu,WAIT,0x%lx,0x%08x,ela=%lu\n",
               nsecs/1000, @wait_node[tid], $wait, $ela);
    }
    delete(@wait_start[tid]); delete(@wait_arg[tid]); delete(@wait_node[tid]);
}

/*
 * ProcSleep - Heavy lock waits
 * Read wait_event_info from MyProc at offset 684
 */
uprobe:/usr/pgsql-13/bin/postgres:ProcSleep /@in_query[tid]/ {
    @lock_start[tid] = nsecs;
    $d = @depth[tid];
    @lock_node[tid] = @node_stack[tid, $d];
    /* Capture wait_event at entry - it should be set by caller */
    $myproc = *uaddr("MyProc");
    @lock_wait[tid] = *(uint32*)($myproc + 684);
}

uretprobe:/usr/pgsql-13/bin/postgres:ProcSleep /@lock_start[tid]/ {
    $ela = (nsecs - @lock_start[tid]) / 1000;
    printf("%lu,LOCK,0x%lx,0x%08x,ela=%lu\n",
           nsecs/1000, @lock_node[tid], @lock_wait[tid], $ela);
    delete(@lock_start[tid]); delete(@lock_node[tid]); delete(@lock_wait[tid]);
}

END {
    printf("\n# === END ===\n");
    clear(@depth); clear(@node_stack); clear(@in_query);
}
