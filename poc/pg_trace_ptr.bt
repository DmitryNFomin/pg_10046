#!/usr/bin/env bpftrace
/*
 * pg_trace_ptr.bt - eBPF tracer with pointer-based node identification
 *
 * Outputs Instrumentation pointer addresses for merging with extension trace.
 * Format: TIM,EVENT,INSTR_PTR,PARENT_PTR,DETAIL
 */

BEGIN {
    printf("# PG_10046 EBPF TRACE\n");
    printf("# TIMESTAMP: %s\n", strftime("%Y%m%d%H%M%S", nsecs));
    printf("# FORMAT: TIM,EVENT,INSTR_PTR,PARENT_PTR,DETAIL\n");
    printf("#\n");
}

/* Query start - standard_ExecutorRun */
uprobe:/usr/pgsql-13/bin/postgres:standard_ExecutorRun {
    @query_start[tid] = nsecs;
    @in_query[tid] = 1;

    /* Read SQL text from QueryDesc */
    $qd = arg0;
    $source_text = *(uint64*)($qd + 16);  /* sourceText offset */

    printf("%lu,QUERY_START,0,0,sql=%s\n",
           nsecs/1000, str($source_text));
}

/* Node start - InstrStartNode(Instrumentation *instr) */
uprobe:/usr/pgsql-13/bin/postgres:InstrStartNode {
    $instr = arg0;

    /* Push to stack */
    @depth[tid]++;
    $d = @depth[tid];
    @node_stack[tid, $d] = $instr;
    @node_start[tid, $d] = nsecs;

    /* Parent is one level up in stack */
    $parent = @node_stack[tid, $d - 1];

    printf("%lu,NODE_START,0x%lx,0x%lx,depth=%d\n",
           nsecs/1000, $instr, $parent, $d);
}

/* Node stop - InstrStopNode(Instrumentation *instr, double nTuples) */
uprobe:/usr/pgsql-13/bin/postgres:InstrStopNode {
    $instr = arg0;
    $d = @depth[tid];
    $start = @node_start[tid, $d];
    $ela = $start > 0 ? (nsecs - $start) / 1000 : 0;

    $parent = @node_stack[tid, $d - 1];

    printf("%lu,NODE_STOP,0x%lx,0x%lx,ela=%lu depth=%d\n",
           nsecs/1000, $instr, $parent, $ela, $d);

    /* Pop from stack */
    @node_stack[tid, $d] = 0;
    @node_start[tid, $d] = 0;
    if ($d > 0) {
        @depth[tid] = $d - 1;
    }
}

/* IO read - mdread(SMgrRelation reln, ForkNumber forknum, BlockNumber blocknum, char *buffer) */
/*
 * SMgrRelation points to SMgrRelationData which starts with RelFileNode:
 *   struct RelFileNode {
 *       Oid spcNode;   // offset 0 - tablespace OID (1663 = pg_default)
 *       Oid dbNode;    // offset 4 - database OID
 *       Oid relNode;   // offset 8 - relation OID
 *   }
 * File path: $PGDATA/base/<dbNode>/<relNode> (for default tablespace)
 */
uprobe:/usr/pgsql-13/bin/postgres:mdread {
    @io_start[tid] = nsecs;
    @io_spc[tid] = *(uint32*)(arg0 + 0);  /* spcNode - tablespace */
    @io_db[tid] = *(uint32*)(arg0 + 4);   /* dbNode - database */
    @io_rel[tid] = *(uint32*)(arg0 + 8);  /* relNode - relation */
    @io_fork[tid] = arg1;                  /* fork number (0=main, 1=fsm, 2=vm) */
    @io_blk[tid] = arg2;

    /* Current node is top of stack */
    $d = @depth[tid];
    @io_node[tid] = @node_stack[tid, $d];
}

uretprobe:/usr/pgsql-13/bin/postgres:mdread /@io_start[tid]/ {
    $ela = (nsecs - @io_start[tid]) / 1000;
    $node = @io_node[tid];
    $blk = @io_blk[tid];
    $seg = $blk / 131072;  /* 1GB / 8KB = 131072 blocks per segment */
    $seg_blk = $blk % 131072;
    $offset = $seg_blk * 8192;  /* Byte offset within segment */

    printf("%lu,IO,0x%lx,0,spc=%u db=%u rel=%u fork=%u seg=%lu blk=%u off=%lu ela=%lu\n",
           nsecs/1000, $node, @io_spc[tid], @io_db[tid], @io_rel[tid],
           @io_fork[tid], $seg, $blk, $offset, $ela);

    /* Accumulate stats */
    @io_count[$node]++;
    @io_time[$node] = @io_time[$node] + $ela;

    delete(@io_start[tid]); delete(@io_rel[tid]);
    delete(@io_blk[tid]); delete(@io_node[tid]);
    delete(@io_spc[tid]); delete(@io_db[tid]); delete(@io_fork[tid]);
}

/* Wait events - WaitEventSetWait (only when in query execution) */
uprobe:/usr/pgsql-13/bin/postgres:WaitEventSetWait /@in_query[tid]/ {
    @wait_start[tid] = nsecs;
    @wait_event[tid] = arg4;

    $d = @depth[tid];
    @wait_node[tid] = @node_stack[tid, $d];
}

uretprobe:/usr/pgsql-13/bin/postgres:WaitEventSetWait /@wait_start[tid] && @in_query[tid]/ {
    $ela = (nsecs - @wait_start[tid]) / 1000;
    if ($ela > 100) {  /* Filter noise < 100us */
        $node = @wait_node[tid];
        $event = @wait_event[tid];

        /* Output full wait event ID for proper decoding:
         * Bits 24-31: class (0x05=Activity, 0x06=Client, 0x0A=IO, etc.)
         * Bits 0-23: event ID within class
         */
        printf("%lu,WAIT,0x%lx,0,event=0x%08x ela=%lu\n",
               nsecs/1000, $node, $event, $ela);

        @wait_count[$node]++;
        @wait_time[$node] = @wait_time[$node] + $ela;
    }
    delete(@wait_start[tid]); delete(@wait_event[tid]); delete(@wait_node[tid]);
}

/* Query end */
uretprobe:/usr/pgsql-13/bin/postgres:standard_ExecutorRun /@query_start[tid]/ {
    $ela = (nsecs - @query_start[tid]) / 1000;
    printf("%lu,QUERY_END,0,0,ela=%lu\n", nsecs/1000, $ela);
    delete(@query_start[tid]);
    delete(@in_query[tid]);
}

END {
    printf("\n# === SUMMARY ===\n");
    printf("# IO count by node:\n");
    print(@io_count);
    printf("# IO time by node (us):\n");
    print(@io_time);
    printf("# Wait count by node:\n");
    print(@wait_count);
    printf("# Wait time by node (us):\n");
    print(@wait_time);

    clear(@depth); clear(@node_stack); clear(@node_start);
    clear(@query_start); clear(@in_query);
    clear(@io_count); clear(@io_time);
    clear(@wait_count); clear(@wait_time);
}
